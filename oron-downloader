#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: sw=4 ts=4 fenc=utf-8

from __future__ import division

import os
import re
import sys
import logging
import subprocess
from lxml import etree
from zope.testbrowser.browser import Browser

logging.basicConfig(format='%(message)s', level=logging.DEBUG)

log = logging.getLogger(__name__)

class OronDownloader(object):
    def __init__(self, downloads_url, username, password, dest_dir=None,
                 generate_thumbs=True, font_path=None):
        self.downloads_url = downloads_url
        self.username = username
        self.password = password
        if dest_dir is None:
            dest_dir = os.getcwd()
        self.dest_dir = dest_dir
        self.generate_thumbs = generate_thumbs
        self.font_path = font_path
        log.info("Starting Browser")
        self.browser = Browser("http://oron.com")
        self.to_download = 0
        self.downloaded = 0

    def login(self):
        log.info("Logging into Oron.com")
        self.browser.open('http://oron.com/login')
        self.browser.getControl(name='login').value = self.username
        self.browser.getControl(name='password').value = self.password
        self.browser.getForm(name='FL').submit(' Submit ')
        if self.username not in self.browser.contents:
            log.error("Failed to login...")
            print self.browser.contents
            sys.exit(1)
        log.info("Logged in successfully")

    def download(self):
        self.login()
        log.info("Opening downloads URL: %s", self.downloads_url)
        self.browser.open(self.downloads_url)
        self.find_download_links(self.browser.contents)

    def find_download_links(self, contents):
        log.info("Searching for download links")
        doc = etree.HTML(contents)
        self.to_download = len(doc.xpath(
            '//table[@class="tbl2"]/tr/td[1]/a[@target="_blank"]/small'
        ))
        log.info("Found %d links to download.", self.to_download)
        trs = doc.xpath('//table[@class="tbl2"]/tr')
        for tr in trs:
            link_td = tr.xpath('td[1]/a')
            size_td = tr.xpath('td[2]/small/nobr/text()')
            if not link_td or not size_td:
                continue

            filename_search = link_td[0].xpath('small/text()')
            if not filename_search:
                continue
            filename = filename_search[0]

            href = link_td[0].attrib['href']
            size = size_td[0].upper()
            fpath = os.path.join(self.dest_dir, filename)
            if os.path.isfile(fpath):
                if self.humanize_bytes(os.path.getsize(fpath)) == size:
                    log.info("Filename %s already downloaded. Skipping...",
                             filename)
                    self.downloaded += 1
                    continue
                log.info("Downloaded %s/%s of %s so far. Continuing...",
                         self.humanize_bytes(os.path.getsize(fpath)), size,
                         filename)
            log.info("Processing %s from %s", filename, href)
            self.download_link(href)
            if self.generate_thumbs:
                try:
                    self.generate_thumb(filename)
                except Exception, err:
                    log.warn("Something went wrong while generating thumbs. "
                             "Disabling thumbs generation.")
                    self.generate_thumbs = False
                    log.exception(err)



    def download_link(self, href):
        self.browser.open(href)
        self.browser.getForm(name='F1').submit(" Create Download Link ")
        self.browser.getLink("Download File")
        fdoc = etree.HTML(self.browser.contents)
        wget_links = fdoc.xpath('//table/tr/td/a[@class="atitle"]')
        for wget_link in wget_links:
            href = wget_link.attrib['href']
        subprocess.call(["wget", "-c", href ])
        self.downloaded += 1
        log.info("Downloaded %s/%s", self.downloaded, self.to_download)


    def humanize_bytes(self, bytes, precision=1):
        """Return a humanized string representation of a number of bytes.

            Assumes `from __future__ import division`.

            >>> humanize_bytes(1)
            '1 byte'
            >>> humanize_bytes(1024)
            '1.0 kB'
            >>> humanize_bytes(1024*123)
            '123.0 kB'
            >>> humanize_bytes(1024*12342)
            '12.1 MB'
            >>> humanize_bytes(1024*12342,2)
            '12.05 MB'
            >>> humanize_bytes(1024*1234,2)
            '1.21 MB'
            >>> humanize_bytes(1024*1234*1111,2)
            '1.31 GB'
            >>> humanize_bytes(1024*1234*1111,1)
            '1.3 GB'
        """
        abbrevs = (
            (1<<50L, 'PB'),
            (1<<40L, 'TB'),
            (1<<30L, 'GB'),
            (1<<20L, 'MB'),
            (1<<10L, 'kB'),
            (1, 'bytes')
        )
        if bytes == 1:
            return '1 byte'
        for factor, suffix in abbrevs:
            if bytes >= factor:
                break
        return '%.*f %s' % (precision, bytes / factor, suffix)

    def generate_thumb(self, filename):
        log.info("Generating thumbs for %s", filename)
        if not os.path.isdir(os.path.join(self.dest_dir, 'screenshots')):
            os.makedirs(os.path.join(self.dest_dir, 'screenshots'))

        cmd = subprocess.Popen([
            'mplayer', '-identify', os.path.join(self.dest_dir, filename)
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        output = cmd.stdout.read()
        match = re.search(r'ID_LENGTH=([\d\.]+)', output)
        try:
            print match.groups()
            skip_length = int(round(float(match.group(1))))/12
        except:
            self.generate_thumbs = False
            log.warn("Something went wrong while generating thumbs. "
                     "Disabling thumbs generation.")
            print output

        try:
            subprocess.call([
                'mtn', '-f', self.font_path,
                '-r', '4',
                '-o', '.jpg',
                '-D', '8',
                '-g', '2',
                '-b', '0.5',
                '-O', os.path.join(self.dest_dir, 'screenshots'),
                '-s', str(skip_length),
                os.path.join(CWD, f)
            ], stderr=subprocess.PIPE)
        except:
            log.warn("Something went wrong while generating thumbs. "
                     "Disabling thumbs generation.")
            self.generate_thumbs = False


if __name__ == '__main__':
    from optparse import OptionParser
    from ConfigParser import SafeConfigParser

    username = password = None
    if os.path.isfile(os.path.expanduser('~/.oron')):
        cfg = SafeConfigParser()
        cfg.read([os.path.expanduser('~/.oron')])
        username = cfg.get('DEFAULT', 'username')
        password = cfg.get('DEFAULT', 'password')
        font = cfg.get('DEFAULT', 'font')


    parser = OptionParser()
    parser.add_option('-u', '--url', help="Oron download url")
    parser.add_option('-U', '--username', help="Oron username", default=username)
    parser.add_option('-P', '--password', help="Oron password", default=password)
    parser.add_option('-d', '--dest-dir', help="Downloads destination directory",
                      default=None)
    parser.add_option('-t', '--generate-thumbs', action='store_true',
                      default=False)
    parser.add_option('-f', '--font', help="Font path to generate the screenshots",
                      default=font)

    options, args = parser.parse_args()
    if not options.url:
        parser.error("You need to pass the Oron downloads URL")
    if not options.username:
        parser.error("You need to pass the Oron username")
    if not options.password:
        parser.error("You need to pass the Oron password")

    if os.path.isfile(options.url):
        options.url = open(options.url, 'r').read().strip()

    downloader = OronDownloader(options.url, options.username,
                                options.password, options.dest_dir,
                                options.generate_thumbs)
    downloader.download()
